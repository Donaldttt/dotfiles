" (jump to the topic)
"
" PLUGIN_INSTALL
" UTILITIES
" PLUGIN_CONFIGURATION
" THEME_CONFIGURATION
" KEY_MAPS
" OTHER_CONFIGS

" PLUGIN_INSTALL
" {
    " Plugin environment
    let g:mydotfiles_directory = expand('~/.dotfiles/')
    let s:plugin_dir = expand('~/.vim/plugged/')

    call plug#begin(s:plugin_dir)

        " https://github.com/junegunn/vim-plug/wiki/tips
        function! Cond(cond, ...)
          let opts = get(a:000, 0, {})
          return a:cond ? opts : extend(opts, { 'on': [], 'for': [] })
        endfunction

        """""""""""""""""""""""
        """" THEME_PLUGINS """"
        """""""""""""""""""""""

        Plug 'sainnhe/everforest', Cond(g:vim_type == 'vim')
        Plug 'NLKNguyen/papercolor-theme'

        " Neovim only
        Plug 'EdenEast/nightfox.nvim', Cond(g:vim_type == 'nvim' && g:vim_version >= 0.5)
        Plug 'projekt0n/github-nvim-theme', Cond(g:vim_type == 'nvim' && g:vim_version >= 0.5, { 'tag': 'v0.0.7' })

        """""""""""""""""""""""
        """""""" END """"""""""
        """""""""""""""""""""""


        Plug 'gelguy/wilder.nvim'
        " To use Python remote plugin features in Vim for wilder, can be skipped
        " Plug 'roxma/nvim-yarp', Cond(g:vim_type == 'vim')
        " Plug 'roxma/vim-hug-neovim-rpc', Cond(g:vim_type == 'vim')

        Plug 'dstein64/vim-startuptime'
        Plug 'simeji/winresizer'
        Plug 'rust-lang/rust.vim', { 'for': ['rust'] }

        Plug 'machakann/vim-sandwich'
        Plug 'rhysd/conflict-marker.vim'

        Plug 'jiangmiao/auto-pairs'
        " Plug 'mg979/vim-visual-multi'
        Plug 'RRethy/vim-illuminate'
        "Plug 'easymotion/vim-easymotion'
        Plug 'mhinz/vim-startify'
        Plug 'ludovicchabant/vim-gutentags', Cond(!exists('g:vscode'), { 'for': ['c', 'cpp'] })

        Plug 'christoomey/vim-tmux-navigator'
        Plug 'airblade/vim-rooter'
        Plug 'roxma/vim-tmux-clipboard', Cond(executable('tmux'))
        Plug 'liuchengxu/vista.vim'

        """""""""""""""""""""""
        "" ESSENTIAL_PLUGINS ""
        """""""""""""""""""""""

        " Comment stuff out
        Plug 'tpope/vim-commentary'
        Plug 'vim-scripts/restore_view.vim'

        " vim only plugins
        Plug 'scrooloose/nerdtree', Cond(g:vim_type == 'vim' \|\| g:vim_version < 0.8, { 'on' : ['NERDTreeToggle', 'NERDTreeFind'] })
        Plug 'tiagofumo/vim-nerdtree-syntax-highlight', Cond(g:vim_type == 'vim')

        Plug 'neoclide/coc.nvim', Cond(!exists('g:vscode') && executable('node'), {'branch': 'release'})

        " only work with vim
        if g:vim_type == 'vim'
            set encoding=UTF-8
            if executable('fzf')
                Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
                Plug 'junegunn/fzf.vim'
                Plug 'antoinemadec/coc-fzf'
            endif

            Plug 'vim-airline/vim-airline'
            Plug 'vim-airline/vim-airline-themes'
            Plug 'Donaldttt/vim-bufferline'
            Plug 'ryanoasis/vim-devicons'
            Plug 'wfxr/minimap.vim', Cond(executable('code-minimap'), {'on' : ['MinimapToggle']})
        endif


        if g:vim_type == 'nvim'
            if g:vim_version >= 0.5
                Plug 'xiyaowong/nvim-transparent'
                Plug 'lukas-reineke/indent-blankline.nvim'
                Plug 'echasnovski/mini.indentscope'
                Plug 'echasnovski/mini.animate'

                Plug 'nvim-lualine/lualine.nvim'
                Plug 'karb94/neoscroll.nvim'
                Plug 'petertriho/nvim-scrollbar'
                Plug 'folke/which-key.nvim'
            endif
            if g:vim_version >= 0.7
                Plug 'nvim-treesitter/nvim-treesitter', Cond(!exists('g:vscode') && executable('make'), {'do': ':TSUpdate'})

                " for telescope
                Plug 'nvim-lua/plenary.nvim'
                Plug 'nvim-telescope/telescope.nvim', Cond(g:vim_type == 'nvim', { 'tag': '0.1.x' })
                " c plugin for telescope to make it faster
                Plug 'nvim-telescope/telescope-fzf-native.nvim', Cond(!exists('g:vscode') && executable('make'), { 'do': 'make' })

                " comment out this plugin if the machine doesn't have required
                " font install
                Plug 'nvim-tree/nvim-web-devicons'
                Plug 'akinsho/toggleterm.nvim', Cond(g:vim_type == 'nvim', {'tag' : '*'})
            endif
            if g:vim_version >= 0.8
                Plug 'nvim-tree/nvim-tree.lua'

                Plug 'rcarriga/nvim-notify'
                Plug 'folke/noice.nvim'
                Plug 'MunifTanjim/nui.nvim'
            endif
        endif

    call plug#end()

    " Automatically install missing plugins at startup
    autocmd VimEnter *
        \  if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
        \|   PlugInstall --sync | q
        \| endif
" }

" UTILITIES
" {

" special filetypes probably defined by plugins that we don't want other
" plugins to mess around with them

let g:special_fts = ['help', 'nerdtree']

function! HasPlug(plug_name, ...)
    let plug_dir_name = get(a:, 1, a:plug_name) " optional argument for the name of plug's folder
    if has_key(g:plugs, a:plug_name) && isdirectory(s:plugin_dir . "/" . plug_dir_name)
        if has_key(g:plugs[a:plug_name], 'for') || has_key(g:plugs[a:plug_name], 'on')
            if (has_key(g:plugs[a:plug_name], 'for') && len(g:plugs[a:plug_name]['for']) == 0) ||
                        \ (has_key(g:plugs[a:plug_name], 'on') && len(g:plugs[a:plug_name]['on']) == 0)
                return v:false
            endif
        endif
        return v:true
    endif
    return v:false
endfunction

" }

" PLUGIN_CONFIGURATION
" {
    if HasPlug('minimap.vim')
        nnoremap <silent> <leader>mm :MinimapToggle<CR>
        let g:minimap_highlight_search = 1
        let g:minimap_git_colors = 1
        let g:minimap_enable_highlight_colorgroup = 1
    endif

    if HasPlug('vista.vim')
        let g:special_fts += ['vista']
        let g:vista_default_executive = 'vim_lsp'
        if HasPlug('coc.nvim')
            let g:vista_default_executive = 'coc'
        elseif HasPlug('coc.nvim')
            let g:vista_default_executive = 'ctags'
        endif
        nnoremap <silent> <leader>v :Vista!!<CR>
        let g:vista_cursor_delay = 0
        let g:vista_echo_cursor = 0
        let g:vista_echo_cursor_strategy = 'floating_win'
        let g:vista_close_on_jump = 0
        let g:vista_floating_delay = 0
        let g:vista_ignore_kinds = ['Variable', 'Field', 'EnumMember',
                    \ 'String', 'Object', 'Array', 'Constant', 'Package', 'Boolean', 'Number'
                    \ ]
        let g:vista_floating_border = 'rounded'
        let g:vista_disable_statusline = 1
        " let g:vista_keep_fzf_colors = 1
        let g:vista_update_on_text_changed_delay = 0
        let g:vista_update_on_text_changed = 1
        let g:vista#renderer#enable_kind = 1
        let g:vista#renderer#enable_icon = 1

        let g:vista_last_row = v:null
        function VistaCursorJump()
            " let found = vista#util#BinarySearch(g:vista.raw, line('.'), 'line', '')
            let found = g:vista_last_row
            if empty(found)
                return
            endif
            let vlnum = get(found, 'vlnum', v:null)
            call cursor(vlnum, 3)
        endfunction

        function VistaH2()
            if exists('*vista#util#BinarySearch')
                let bufs = map(filter(copy(getbufinfo()), 'v:val.listed'), 'v:val.bufnr')
                if index(bufs, bufnr('%')) < 0
                    return
                endif
                let found = vista#util#BinarySearch(g:vista.raw, line('.'), 'line', '')
                if empty(found)
                    return
                endif
                let g:vista_last_row = found
            endif
        endfunction

        autocmd BufLeave * call VistaH2()
        " autocmd WinLeave call VistaH2()
        autocmd FileType vista call VistaCursorJump()

        function VistaHelper()
            if winnr('$') == 1 && bufname() == "__vista__"
                let bufs = map(filter(copy(getbufinfo()), 'v:val.listed'), 'v:val.bufnr')
                if len(bufs) > 1
                   execute("normal! :bw\<CR>")
                else
                    execute "normal! :q!\<CR>"
                endif
            endif
        endfunction

        " close vista when it is the last window
        " autocmd BufEnter * if winnr('$') == 1 && bufname() == "__vista__" | execute "normal! :q!\<CR>" | endif
        " autocmd BufEnter * call VistaHelper()

    endif

    if HasPlug('indentLine')
        let g:indentLine_fileTypeExclude = ['startify']
    endif

    if HasPlug('vim-illuminate') && g:vim_type == 'vim'
        let g:Illuminate_ftHighlightGroups = {
        \ 'vim': ['vimVar', 'vimString', 'vimFuncName',
        \ 'vimFunction', 'vimUserFunc', 'vimFunc'],
        \ 'java:blacklist' : [ 'javaType', 'javaScopeDecl', 'javaMethodDecl',
        \ 'javaComment', 'javaStorageClass', 'javaClassDecl', 'javaExternal',
        \ 'javaTypedef', 'javaLineComment', 'javaStatement', 'javaCommentTitle', 'javaDocComment' ],
        \ 'lua:blacklist' : [ 'luaComment', 'luaCond', 'luaStatement', 'luaFunction' ]
        \ }
        let g:Illuminate_ftwhitelist = ['vim', 'sh', 'python', 'rust', 'java', 'c', 'cpp', 'javascript', 'typescript', 'lua']

        augroup illuminate_augroup
            autocmd!
            " autocmd VimEnter * hi link illuminatedWord CursorLine
            autocmd VimEnter * hi illuminatedWord cterm=underline gui=underline
            autocmd ColorScheme * hi illuminatedWord cterm=underline gui=underline
        augroup END
    endif

    if HasPlug('wilder.nvim')

        call wilder#setup({
            \ 'modes': [':'],
            \ 'next_key': '<tab>',
            \ 'enable_cmdline_enter': 0,
            \ })

        call wilder#set_option('pipeline', [
            \   wilder#debounce(10),
            \   wilder#branch(
            \     wilder#cmdline_pipeline({'language': g:vim_type == 'nvim' ? 'python' : 'vim'}),
            \   ),
            \ ])
        call wilder#set_option('renderer', wilder#popupmenu_renderer())
    endif

    if HasPlug('vim-tmux-navigator')
        let g:tmux_navigator_no_mappings = 1

        noremap <silent> <c-h> :<C-U>TmuxNavigateLeft<cr>
        noremap <silent> <c-j> :<C-U>TmuxNavigateDown<cr>
        noremap <silent> <c-k> :<C-U>TmuxNavigateUp<cr>
        noremap <silent> <c-l> :<C-U>TmuxNavigateRight<cr>
        " noremap <silent> {Previous-Mapping} :<C-U>TmuxNavigatePrevious<cr>
    endif

    " mhinz/vim-startify {
    if HasPlug("vim-startify")
        if g:vim_type == 'nvim'
            let buffer_str_len = (&columns - 60) / 2
            let buf_str = repeat(' ', buffer_str_len)
            let g:startify_custom_header = [
                \ buf_str . ' __    __  ________   ______   __     __  ______  __       __ ',
                \ buf_str . '|  \  |  \|        \ /      \ |  \   |  \|      \|  \     /  \',
                \ buf_str . '| $$\ | $$| $$$$$$$$|  $$$$$$\| $$   | $$ \$$$$$$| $$\   /  $$',
                \ buf_str . '| $$$\| $$| $$__    | $$  | $$| $$   | $$  | $$  | $$$\ /  $$$',
                \ buf_str . '| $$$$\ $$| $$  \   | $$  | $$ \$$\ /  $$  | $$  | $$$$\  $$$$',
                \ buf_str . '| $$\$$ $$| $$$$$   | $$  | $$  \$$\  $$   | $$  | $$\$$ $$ $$',
                \ buf_str . '| $$ \$$$$| $$_____ | $$__/ $$   \$$ $$   _| $$_ | $$ \$$$| $$',
                \ buf_str . '| $$  \$$$| $$     \ \$$    $$    \$$$   |   $$ \| $$  \$ | $$',
                \ buf_str . ' \$$   \$$ \$$$$$$$$  \$$$$$$      \$     \$$$$$$ \$$      \$$',
                \]
        else
            let buffer_str_len = (&columns - 30) / 2
            let buf_str = repeat(' ', buffer_str_len)
            let g:startify_custom_header = [
                \ buf_str . ' __     __  ______  __       __ ',
                \ buf_str . '|  \   |  \|      \|  \     /  \',
                \ buf_str . '| $$   | $$ \$$$$$$| $$\   /  $$',
                \ buf_str . '| $$   | $$  | $$  | $$$\ /  $$$',
                \ buf_str . ' \$$\ /  $$  | $$  | $$$$\  $$$$',
                \ buf_str . '  \$$\  $$   | $$  | $$\$$ $$ $$',
                \ buf_str . '   \$$ $$   _| $$_ | $$ \$$$| $$',
                \ buf_str . '    \$$$   |   $$ \| $$  \$ | $$',
                \ buf_str . '     \$     \$$$$$$ \$$      \$$',
                \]
        endif

        let g:startify_lists = [
            \ { 'header': ['   RECENT'],            'type': 'files' },
            \ { 'header': ['   SESSIONS'],       'type': 'sessions' },
        \ ]

        " session related KeyBinding. These KeyBinding uses function from startify
        nnoremap <silent> <leader><leader>s :SSave!<CR>
        nnoremap <silent> <leader><leader>l :SLoad<CR>
        nnoremap <silent> <leader><leader>d :SDelete!<CR>
        nnoremap <silent> <leader><leader>c :SClose<CR>

    endif
    " }
    "
    " ryanoasis/vim-devicons {
    if HasPlug("vim-devicons")
        let g:webdevicons_enable_airline_statusline = 0
    endif
    " }
    "
    " simeji/winresizer {
    if HasPlug("winresizer")
        let g:winresizer_vert_resize  = 2
        let g:winresizer_horiz_resize = 2
        " nnoremap <C-w>r :WinResizerStartResize<CR>
        let g:winresizer_start_key = '<C-w>r'
    endif
    " }

    " ludovicchabant/vim-gutentags {
    if HasPlug("vim-gutentags")
        if exists("*gutentags#statusline()")
            set statusline+=%{gutentags#statusline()}
        endif
        let g:gutentags_cache_dir=g:vim_dir . '/.vimtags/'
        let g:gutentags_project_root=['.git', '.hg', '.svn', '.bzr', '_darcs', '_FOSSIL_', '.fslckout', 'src']
    endif
    " }

    " easymotion/vim-easymotion {
    if HasPlug("vim-easymotion")
        " <Leader>f{char} to move to {char}
        map  <Leader>f <Plug>(easymotion-bd-f)
        nmap <Leader>f <Plug>(easymotion-overwin-f)

        " s{char}{char} to move to {char}{char}
        nmap s <Plug>(easymotion-overwin-f2)

        " Move to line
        map <Leader>L <Plug>(easymotion-bd-jk)
        nmap <Leader>L <Plug>(easymotion-overwin-line)

        " Move to word
        map  <Leader>w <Plug>(easymotion-bd-w)
        nmap <Leader>w <Plug>(easymotion-overwin-w)
    endif

    " }

    " antoinemadec/coc-fzf {
    if HasPlug("coc-fzf")
        " nnoremap <silent> <space><space> :<C-u>CocFzfList<CR>
        " nnoremap <leader>o       :<C-u>CocFzfList outline<CR>
    endif
    " }

    " bling/vim-bufferline {
    if HasPlug("vim-bufferline") && HasPlug("vim-airline")
        let g:bufferline_echo = 0
        let g:bufferline_modified = '+'

        " scrolling with fixed current buffer position

        let g:bufferline_active_buffer_left = ''
        let g:bufferline_active_buffer_right = ''
        " let g:bufferline_inactive_highlight = 'StatusLineNC'
        " let g:bufferline_active_highlight = 'StatusLine'
    endif

    " }

    " mbbill/undotree {
    if HasPlug("undotree")
        nnoremap <leader>ut :UndotreeToggle<CR>
    endif
    " }

    " airblade/vim-rooter {
    if HasPlug("vim-rooter")
        let g:rooter_patterns = ['.vscode', '.git', '*.sln', 'src']
        let g:rooter_change_directory_for_non_project_files = 'current'
        let g:rooter_silent_chdir = 1
    endif
    " }

    " NerdTree {
    if (g:vim_type == 'vim' || g:vim_version < 0.8) && HasPlug('nerdtree')
        if HasPlug('vim-nerdtree-syntax-highlight')
            let g:NERDTreeLimitedSyntax = 1
        endif
        let g:NERDShutUp=1

        " work around for nerdtree bug: https://github.com/preservim/nerdtree/issues/1321
        let g:NERDTreeMinimalMenu = v:true
        let g:NERDTreeMinimalUI = v:true

        "nnoremap <C-e> :NERDTreeToggle<CR>
        function! NERDTreeFindToggle()
            let my_filetype = &filetype
            let specical_fts = ['nerdtree', 'startify']
            if  my_filetype == '' || index(specical_fts, my_filetype) >= 0
                :NERDTreeToggle
            else
                :NERDTreeFind
            endif
        endfunction
        nnoremap <silent> <leader>e :call NERDTreeFindToggle()<CR>

        "let NERDTreeShowBookmarks=1
        "let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
        let NERDTreeChDirMode        = 0
        let NERDTreeQuitOnOpen       = 1
        let NERDTreeMouseMode        = 2
        let NERDTreeShowHidden       = 1

        if HasPlug('vim-devicons') || HasPlug('nerdfont.vim')
            let NERDTreeDirArrowCollapsible = ''
            let NERDTreeDirArrowExpandable = ''
        else
            " let NERDTreeDirArrowCollapsible = ''
            " let NERDTreeDirArrowExpandable = ''
        endif
        " Exit Vim if NERDTree is the only window remaining in the only tab.
        autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif
    endif
    " }

    " nvim-tree.lua {
    if g:vim_type == 'nvim' && HasPlug("nvim-tree.lua")
    endif
    " }

    if HasPlug("vim-airline")

        function! AirlineCocStatus()
            if ! exists('*CocAction')
                return
            endif
            " let loading = ["⢿", "⣻", "⣽", "⣾", "⣷", "⣯", "⣟", "⡿"]
            let loading = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]
            try
                let result = CocAction('services')
            catch
                return
            endtry
            let state = ''
            let id = ''
            for e in result
                if e['languageIds'][0] == &ft
                    let state = e['state']
                    let id = e['id']
                endif
            endfor

            " messy way to get time in millisecond in vim
            let time = float2nr(str2float(reltime()->reltimestr()[4:]) * 1000)
            let speed = 800
            let loadidx = time % speed
            let msg = 'lsp[' . id . ']'
            if state == "starting"
                return msg . " " . loading[loadidx/(speed/10)]
            endif
            return msg . " ✔"
        endfunction

        " Set configuration options for the statusline plugin vim-airline.
        " Use the powerline theme and optionally enable powerline symbols.

        " This must using my fork version of bufferline

        " TODO
        " 22 is a magic number, it is best it can change as buffer width
        " changing
        let g:bufferline_max_length = &columns - 22
        function! AirlineBufferNumber()
            return len(g:index_to_buffer)
        endfunction
        call airline#parts#define_function('bufnum', 'AirlineBufferNumber')
        call airline#parts#define_function('cocstatus', 'AirlineCocStatus')
        call airline#parts#define_accent('cocstatus', 'italic')

        function! AirlineInit()
            " this create function returns a format string for status line (:h
            " stl). the string we append is what will happend if we pass
            " cocstatus into the create function. By appending them we have
            " more freedom format the highlight
            " let g:airline_section_y       = '%{%airline#util#wrap(AirlineCocStatus(), 0)%}'
            let g:airline_section_a       = airline#section#create(['mode'])
            let g:airline_section_b       = ''
            let g:airline_section_error       = ''
            let g:airline_section_warning       = ''
            let g:airline_section_x       = airline#section#create(['bufnum'])
            let g:airline_section_y       = airline#section#create(['cocstatus'])
            let g:airline_section_z       = airline#section#create(['filetype'])
            " see source for current list
        endfunction
        autocmd User AirlineAfterInit call AirlineInit()

        let g:airline#extensions#localsearch#enabled = 0
        let g:airline_extensions = ['bufferline']

        let g:airline_exclude_filetypes = ['vista', 'minimap']
        let g:airline_skip_empty_sections = 1
        " without this airline will overwrite some setting like bufferline_active_buffer_left, etc.
        let g:airline#extensions#bufferline#overwrite_variables = 0
        let g:airline_mode_map = {
            \ '__'     : '-',
            \ 'c'      : 'C',
            \ 'i'      : 'I',
            \ 'ic'     : 'I',
            \ 'ix'     : 'I',
            \ 'n'      : 'N',
            \ 'multi'  : 'M',
            \ 'ni'     : 'N',
            \ 'no'     : 'N',
            \ 'R'      : 'R',
            \ 'Rv'     : 'R',
            \ 's'      : 'S',
            \ 'S'      : 'S',
            \ ''     : 'S',
            \ 't'      : 'T',
            \ 'v'      : 'V',
            \ 'V'      : 'V',
            \ ''     : 'V',
            \ }

        if HasPlug("vim-airline-themes/")
            "let g:airline_theme = 'solarized'
        endif
    endif
    " }
    "endif

    " junegunn/fzf {
    if HasPlug("fzf") && HasPlug("fzf.vim")
        " [Buffers] Jump to the existing window if possible
        let g:fzf_buffers_jump = 1

        "let $FZF_DEFAULT_COMMAND='find . \( -name node_modules -o -name .git \) -prune -o -print'

        "   - Preview window on the right with 50% width
        "   - CTRL-/ will toggle preview window.
        if g:os == 'Windows'
            let g:fzf_preview_window = []
        else
            let g:fzf_preview_window = ['right:50%', 'ctrl-/']
        end

        " check if ripgrep is installed
        if ! executable('rg')
            command! -bang -nargs=* Rg
              \ call fzf#vim#grep(
              \   'grep -R --line-number --exclude-dir=".git;.svn" --color=always -- '.shellescape(<q-args>), 1,
              \   fzf#vim#with_preview(), <bang>0)
        endif
        noremap <leader>fr :Rg<CR>
        noremap <leader>ff :Files<CR>
        noremap <leader>fc :Colors<CR>
    endif
    " }

    " neoclide/coc.nvim {
    if HasPlug("coc.nvim") && executable('node')
        " coc-clangd: c/c++, may need to install clangd seperatly

        if filereadable(g:mydotfiles_directory . "/coc-nvim-config.vim")
            exec "source " . g:mydotfiles_directory . "/coc-nvim-config.vim"
        endif
        " warning that coc work best for vim >= 8.3
        let g:coc_disable_startup_warning = 1
    endif

    " }
" }

" THEME_CONFIGURATION
" {
    " GOTO menu
    " THEME_README
    " THEME_PLUGINS_CONFIG
    " THEME_ULTILITIES
    " THEME_INIT            " Setup theme when vim first start
    " THEME_OPTIONS

    """""""""""""""""""""""""""""""""""""""
    """""""""""" THEME_README """""""""""""
    """""""""""""""""""""""""""""""""""""""

    " set custom callback functions to use when when enabling/diabling transparent
    " for certain colorscheme
    "     let g:light_transparent_enable_cb = ''
    "     let g:light_transparent_disable_cb = ''
    "     let g:dark_transparent_enable_cb = ''
    "     let g:dark_transparent_disable_cb = ''

    """""""""""""""""""""""""""""""""""""""
    """"""" THEME_PLUGINS_CONFIG """"""""""
    """""""""""""""""""""""""""""""""""""""

    " a list contains all available themes
    let g:all_dark_themes = []
    let g:all_light_themes = []

    if HasPlug("github-nvim-theme")
        let g:all_dark_themes += ['github_dark', 'github_dark_default', 'github_dimmed', 'github_dark_colorblind']
        let g:all_light_themes += ['github_light', 'github_light_default', 'github_light_colorblind']
    end

    if HasPlug("nightfox.nvim")
        let g:all_dark_themes += ['nightfox']
        let g:all_light_themes += ['dawnfox']
    end

    if HasPlug('nvim-transparent')

        " generic nvim transparent enable and disable function
        function Nvim_TB_enable()
            :TransparentEnable
        endfunction
        function Nvim_TB_disable()
            :TransparentDisable
        endfunction

        let g:light_transparent_enable_cb = 'Nvim_TB_enable'
        let g:light_transparent_disable_cb = 'Nvim_TB_disable'
        let g:dark_transparent_enable_cb = 'Nvim_TB_enable'
        let g:dark_transparent_disable_cb = 'Nvim_TB_disable'
    endif

    if HasPlug('everforest')
        let g:all_dark_themes += ['everforest']
        let g:all_light_themes += ['everforest']

        let g:everforest_better_performance = 1
        let g:everforest_background = 'hard'
        " let g:everforest_enable_italic = 1
        function! Everforest_trans_enable()
            let g:everforest_transparent_background = 2
            colorscheme everforest
            if exists(':AirlineTheme')
                execute('AirlineTheme  everforest')
            endif
            " hack to fix caret characters appearing in the statusline when StatusLine
            " and StatusLineNC has same highlight(https://vi.stackexchange.com/questions/15873/carets-in-status-line)
            hi StatusLine guifg=#d3c6aa ctermfg=223
        endfunction
        function! Everforest_trans_disable()
            let g:everforest_transparent_background = 0
            colorscheme everforest
            if exists(':AirlineTheme')
                execute('AirlineTheme  everforest')
            endif
        endfunction
        function! CB_dark_tb_enable_everforest()
            call Everforest_trans_enable()
        endfunction
        function! CB_light_tb_enable_everforest()
            call Everforest_trans_enable()
        endfunction
        function! CB_dark_tb_disable_everforest()
            call Everforest_trans_disable()
        endfunction
        function! CB_light_tb_disable_everforest()
            call Everforest_trans_disable()
        endfunction

    endif
    if HasPlug('papercolor-theme')
        let g:all_dark_themes += ['PaperColor']
        let g:all_light_themes += ['PaperColor']

        function! CB_dark_tb_enable_PaperColor()
            let g:PaperColor_Theme_Options = {
            \   'theme': {'default.dark': { 'transparent_background': 1 }}
            \ }
            execute("colorscheme " . g:dark_theme)
        endfunction
        function! CB_light_tb_enable_PaperColor()
            let g:PaperColor_Theme_Options = {
            \   'theme': {'default.light': { 'transparent_background': 1 }}
            \ }
            execute("colorscheme " . g:light_theme)
        endfunction
        function! CB_dark_tb_disable_PaperColor()
            let g:PaperColor_Theme_Options = {
            \   'theme': {'default.dark': { 'transparent_background': 0 }}
            \ }
            execute("colorscheme " . g:dark_theme)
        endfunction
        function! CB_light_tb_disable_PaperColor()
            let g:PaperColor_Theme_Options = {
            \   'theme': {'default.light': { 'transparent_background': 0 }}
            \ }
            execute("colorscheme " . g:light_theme)
        endfunction
    endif

    """""""""""""""""""""""""""""""""""""""
    """""""""" THEME_ULTILITIES """""""""""
    """""""""""""""""""""""""""""""""""""""

    " debug function print out highlight group of cursor position
    function! ShowHighLightGroup()
        if !exists("*synstack")
            return
        endif
        echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')

        :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
        \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
        \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"

    endfunc

    nmap <Leader>db :call ShowHighLightGroup()<CR>

    " search and filter highlight group
    " :call Sh('airline')
    function! Sh(pattern)
        execute("filter /" . a:pattern . "/ highlight")
    endfunc

    " get current colorscheme name
    function! ColourSchemeName()
        try
            return g:colors_name
        catch /^Vim:E121/
            return "default"
        catch /.*/
            return "default"
        endtry
    endfunction

    " delete signal file if exist
    function! DeleteSignalFile(name)
        if filereadable(g:vim_dir . a:name)
            call delete(g:vim_dir . a:name)
        endif
    endfunction

    " Create signal file if not exist
    function! CreateSignalFile(name)
        call system("touch " . g:vim_dir . a:name)
    endfunction

    function! SignalFileExists(filename)
        if filereadable(g:vim_dir . a:filename)
            return v:true
        endif
        return v:false
    endfunction

    function! SetDarkTheme()
        set background=dark
        " hi clear
        execute("colorscheme " . g:dark_theme)
        let g:dark_or_light_theme = 'dark'
    endfunction

    function! SetLightTheme()
        set background=light
        " hi clear
        execute("colorscheme " . g:light_theme)
        execute("colorscheme " . g:light_theme)
        let g:dark_or_light_theme = 'light'
    endfunction

    " Change bottom airline/lualine theme
    function! SetStatusLineTheme(theme)
        if g:vim_type == 'nvim' && g:vim_version >= 0.5
            " lualine will change theme automatically
        else
            if HasPlug('vim-airline') && HasPlug('vim-airline-themes')
                execute('AirlineTheme ' . a:theme)
            endif
        endif
    endfunction

    function! EnableTransparent()
        let colorscheme_name = ColourSchemeName()
        if g:dark_or_light_theme == 'dark'
            let dark_cb_name = 'CB_dark_tb_enable_' . colorscheme_name
            if exists('*' . dark_cb_name)
                execute('call ' . dark_cb_name . '()')
            elseif g:dark_transparent_enable_cb != ''
                execute('call ' . g:dark_transparent_enable_cb . '()')
            else
                return
            endif
            let g:transparent_dark_theme = v:true
            call CreateSignalFile('.transparent_dark_theme.signal')
        else
            let light_cb_name = 'CB_light_tb_enable_' . colorscheme_name
            if exists('*' . light_cb_name)
                execute('call ' . light_cb_name . '()')
            elseif g:light_transparent_enable_cb != ''
                execute('call ' . g:light_transparent_enable_cb . '()')
            else
                return
            endif
            let g:transparent_light_theme = v:true
            call CreateSignalFile('.transparent_light_theme.signal')
        endif
    endfunction

    function! DisableTransparent()
        let colorscheme_name = ColourSchemeName()
        if g:dark_or_light_theme == 'dark'
            let dark_cb_name = 'CB_dark_tb_disable_' . colorscheme_name
            if exists('*' . dark_cb_name)
                set background=dark
                execute('call ' . dark_cb_name . '()')
            elseif g:dark_transparent_disable_cb != ''
                execute('call ' . g:dark_transparent_disable_cb . '()')
            else
                return
            endif
            let g:transparent_dark_theme = v:false
            call DeleteSignalFile('.transparent_dark_theme.signal')
        else
            let light_cb_name = 'CB_light_tb_disable_' . colorscheme_name
            if exists('*' . light_cb_name)
                set background=light
                execute('call ' . light_cb_name . '()')
            elseif g:light_transparent_disable_cb != ''
                execute('call ' . g:light_transparent_disable_cb . '()')
            else
                return
            endif
            let g:transparent_light_theme = v:false
            call DeleteSignalFile('.transparent_light_theme.signal')
        endif
        " if g:vim_type == 'nvim' && g:vim_version > 0.5
        "     :TransparentDisable
        " endif
    endfunction

    " ToggleTransparent background
    function! ToggleTransparent()
        if g:transparent_dark_theme && g:dark_or_light_theme == 'dark'
            call DisableTransparent()
        elseif g:transparent_light_theme && g:dark_or_light_theme == 'light'
            call DisableTransparent()
        elseif ! g:transparent_light_theme && g:dark_or_light_theme == 'light'
            call EnableTransparent()
        elseif ! g:transparent_dark_theme && g:dark_or_light_theme == 'dark'
            call EnableTransparent()
        endif
    endfunction

    " Allow to trigger background
    function! ToggleBG()
        " Inversion
        if g:dark_or_light_theme == "dark"
            call SetLightTheme()
            call SetStatusLineTheme(g:airline_light_theme)
            call CreateSignalFile('.light_theme.signal')
        else
            call SetDarkTheme()
            call SetStatusLineTheme(g:airline_dark_theme)
            call DeleteSignalFile('.light_theme.signal')
        endif

        if (g:transparent_dark_theme && g:dark_or_light_theme == 'dark') || (g:transparent_light_theme && g:dark_or_light_theme == 'light')
            call EnableTransparent()
        else
            call DisableTransparent()
        endif
    endfunction

    """""""""""""""""""""""""""""""""""""""
    """"""""""""" THEME_INIT """"""""""""""
    """""""""""""""""""""""""""""""""""""""

    " transparent backgroud for supported terminal emulator
    " check if transparent_dark_theme.signl or transparent_light_theme.signl
    " exist and set respect variable
    let g:transparent_dark_theme = v:false
    let g:transparent_light_theme = v:false

    function! Theme_initilize()
        if SignalFileExists('.transparent_dark_theme.signal')
            let g:transparent_dark_theme = v:true
        endif
        if SignalFileExists('.transparent_light_theme.signal')
            let g:transparent_light_theme = v:true
        endif

        " dark or light
        if filereadable(g:vim_dir . '.light_theme.signal')
            let g:dark_or_light_theme = 'light'
        else
            let g:dark_or_light_theme = 'dark'
        endif

        if g:dark_or_light_theme == 'dark'
            let g:airline_theme=g:airline_dark_theme
            call SetDarkTheme()
        else
            let g:airline_theme=g:airline_light_theme
            call SetLightTheme()
        endif
        if (g:transparent_dark_theme && g:dark_or_light_theme == 'dark')
                    \  || (g:transparent_light_theme && g:dark_or_light_theme == 'light')
            call EnableTransparent()
        else
            call DisableTransparent()
        endif
    endfunction
    au! VimEnter * call Theme_initilize()

    """""""""""""""""""""""""""""""""""""""
    """"""""""" THEME_OPTIONS """""""""""""
    """""""""""""""""""""""""""""""""""""""

    " Default
    let g:dark_theme = 'default'
    let g:light_theme = 'default'

    " for airline
    let g:airline_dark_theme = "angr"
    let g:airline_light_theme = "silver"

    " vim theme
    if g:vim_type == 'vim'
        set t_Co=256
        if has('termguicolors')
          set termguicolors
        endif

        if HasPlug("papercolor-theme")
            " improve coc color in this theme
            let g:light_theme = 'PaperColor'
        endif

        if HasPlug("everforest")
            let g:light_theme = 'everforest'
            let g:dark_theme = 'everforest'
            let g:airline_dark_theme = "everforest"
            let g:airline_light_theme = "everforest"
        endif
    endif

    if g:vim_type == 'nvim'
        if HasPlug("nightfox.nvim")
            let g:light_theme = 'dawnfox'
            let g:dark_theme = 'nightfox'
        end

        if HasPlug("github-nvim-theme")
            let g:dark_theme = 'github_dark'
            let g:airline_dark_theme = "hybrid"
        end
    endif

" }

" KEY_MAPS
" (This doesn't include plugin specific mapping.
" For them please check plugin Preferences)
" {

    " Toggle dark/light theme
    noremap <silent> <leader>bg :call ToggleBG()<CR>

    " Toggle transparent background
    noremap <silent> <leader>tb :call ToggleTransparent()<CR>

    " Buffer navigation
    nnoremap <silent> <space>q :bprevious<CR>
    nnoremap <silent> <space>e :bnext<CR>

    " leader s change all occurence
    nnoremap <Leader>s :%s/\<<C-r><C-w>\>/<C-r><C-w>

    " leader num change tab
    " only for vim or nvim without lualine
    if g:vim_type == 'vim' || (g:vim_type == 'nvim' && g:vim_version < 0.5)
        for i in range(1, 9)
            execute "nnoremap <silent> <nowait> <leader>" . i .
                \ " :call bufferline#jump(" . i . ")<CR>"
        endfor
        for i in range(10, 20)
            execute "nnoremap <silent> <nowait> <space>" . i .
                \ " :call bufferline#jump(" . i . ")<CR>"
        endfor
    end

    " split window comform with other window management shortcuts
    nnoremap <silent> <C-w>% :vsplit<CR>
    nnoremap <silent> <C-w>" :split<CR>
" }

" Lua configuration
if g:vim_type == 'nvim' && filereadable(g:mydotfiles_directory . '.vimrc.lua')
    execute('source ' . g:mydotfiles_directory . '/.vimrc.lua')
endif

" OTHER_CONFIGS

if filereadable(g:mydotfiles_directory . "/config/theme.vim")
    " exec "source " . g:mydotfiles_directory . "/config/theme.vim"
endif
