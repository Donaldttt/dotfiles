" If anything not work as expected. Please make sure all plugins
" are installed by running:
" :PlugInstall
"
" Content
" ('#' jump to the topic)
"
" Plugin_Install
" Plugin_Preferences
" Theme_Appearance
" Key_Mappings
" Useful_Info

" Environment {
    set nocompatible        " Must be first line
" }
    
" Plugin_Install
" {
    " Plugin environment
    let g:mydotfiles_directory = expand('~/.dotfiles/')
    let s:plugin_dir = expand('~/.vim/plugged/')
    let g:vim_dir = expand('~/.vim/')

    call plug#begin(s:plugin_dir)

        "Plug 'NoahTheDuke/vim-just'
        " Plug 'mbbill/undotree'
        " {
            " Plug 'alvan/vim-closetag'
            " let g:closetag_filenames = '*.html,*.xhtml,*.phtml, *.js'
        " }

        " for markdown{
            " Plug 'preservim/vim-markdown'
        "}
        
        Plug 'dstein64/vim-startuptime'
        Plug 'simeji/winresizer'
        Plug 'rust-lang/rust.vim'
        
        Plug 'tpope/vim-surround'
        Plug 'rhysd/conflict-marker.vim'

        Plug 'jiangmiao/auto-pairs'
        Plug 'mg979/vim-visual-multi'

        "Plug 'easymotion/vim-easymotion'
        Plug 'vim-scripts/restore_view.vim'
        Plug 'mhinz/vim-startify'

        if executable('fzf')
            " fzf#install() makes sure that you have the latest binary, comment out because I don't want it to install binary for me
            Plug 'junegunn/fzf' ", { 'do': { -> fzf#install() } }
            Plug 'junegunn/fzf.vim'
            Plug 'antoinemadec/coc-fzf'
        endif

        Plug 'NLKNguyen/papercolor-theme'
        Plug 'airblade/vim-rooter'

        " Comment stuff out
        Plug 'tpope/vim-commentary' 

        " put text in neibouring tmux pane into auto complete
        Plug 'wellle/tmux-complete.vim'

        Plug 'ludovicchabant/vim-gutentags', { 'for': ['c', 'cpp'] }
        Plug 'lambdalisue/readablefold.vim'

        " only work with vim 
        if g:vim_type == 'vim'
            set encoding=UTF-8
            Plug 'scrooloose/nerdtree'
            Plug 'tiagofumo/vim-nerdtree-syntax-highlight'
            " Plug 'tribela/vim-transparent'
            Plug 'vim-airline/vim-airline'
            Plug 'vim-airline/vim-airline-themes'
            " The bottom buffer display
            Plug 'Donaldttt/vim-bufferline'
            Plug 'ryanoasis/vim-devicons'
            Plug 'Yggdroot/indentLine'
        endif

        if executable('node')
             Plug 'neoclide/coc.nvim', {'branch': 'release'}
        endif

        " only work with nvim > 0.5
        " For other versions, just loading the plugin may
        " cause error
        if g:vim_type == 'nvim'
            if g:vim_version >= 0.5
                Plug 'xiyaowong/nvim-transparent'
                Plug 'lukas-reineke/indent-blankline.nvim'
                " nvim theme
                Plug 'EdenEast/nightfox.nvim'
                Plug 'projekt0n/github-nvim-theme', { 'tag': 'v0.0.7' }

                Plug 'nvim-lualine/lualine.nvim'

                "{ lsp-zero
                
                    " LSP Support
                    " Plug 'neovim/nvim-lspconfig'             " Required
                    " Plug 'williamboman/mason.nvim'           " Optional
                    " Plug 'williamboman/mason-lspconfig.nvim' " Optional

                    " " Autocompletion Engine
                    " Plug 'hrsh7th/nvim-cmp'         " Required
                    " Plug 'hrsh7th/cmp-nvim-lsp'     " Required
                    " Plug 'hrsh7th/cmp-buffer'       " Optional
                    " Plug 'hrsh7th/cmp-path'         " Optional
                    " Plug 'saadparwaiz1/cmp_luasnip' " Optional
                    " Plug 'hrsh7th/cmp-nvim-lua'     " Optional

                    " "  Snippets
                    " Plug 'L3MON4D3/LuaSnip'             " Required
                    " Plug 'rafamadriz/friendly-snippets' " Optional

                    " Plug 'VonHeikemen/lsp-zero.nvim', {'branch': 'v1.x'}
                "}

            endif
            if g:vim_version >= 0.7
                Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}

                " comment out this plugin if the machine doesn't have required
                " font install
                Plug 'nvim-tree/nvim-web-devicons'
                Plug 'ziontee113/color-picker.nvim'
            endif
            if g:vim_version >= 0.8
                Plug 'nvim-tree/nvim-tree.lua'
            endif
            if g:vim_version < 0.8
                Plug 'scrooloose/nerdtree'
            endif
        endif

    call plug#end()
" }

function! HasPlug(plug_name, ...)
    let plug_dir_name = get(a:, 1, a:plug_name) " optional argument for the name of plug's folder
    if has_key(g:plugs, a:plug_name) && isdirectory(s:plugin_dir . "/" . plug_dir_name)
        return v:true
    endif
        return v:false
endfunction

" Plugin_Preferences
" {
    " Yggdroot/indentLine {
    if HasPlug('indentLine')
        let g:indentLine_fileTypeExclude = ['startify']
    endif
    " }

    " mhinz/vim-startify {
    if HasPlug("vim-startify")
        if g:vim_type == 'nvim'
            let buffer_str_len = (&columns - 60) / 2
            let buf_str = repeat(' ', buffer_str_len)
            let g:startify_custom_header = [
                \ buf_str . ' __    __  ________   ______   __     __  ______  __       __ ',
                \ buf_str . '|  \  |  \|        \ /      \ |  \   |  \|      \|  \     /  \',
                \ buf_str . '| $$\ | $$| $$$$$$$$|  $$$$$$\| $$   | $$ \$$$$$$| $$\   /  $$',
                \ buf_str . '| $$$\| $$| $$__    | $$  | $$| $$   | $$  | $$  | $$$\ /  $$$',
                \ buf_str . '| $$$$\ $$| $$  \   | $$  | $$ \$$\ /  $$  | $$  | $$$$\  $$$$',
                \ buf_str . '| $$\$$ $$| $$$$$   | $$  | $$  \$$\  $$   | $$  | $$\$$ $$ $$',
                \ buf_str . '| $$ \$$$$| $$_____ | $$__/ $$   \$$ $$   _| $$_ | $$ \$$$| $$',
                \ buf_str . '| $$  \$$$| $$     \ \$$    $$    \$$$   |   $$ \| $$  \$ | $$',
                \ buf_str . ' \$$   \$$ \$$$$$$$$  \$$$$$$      \$     \$$$$$$ \$$      \$$',
                \]
        else
            let buffer_str_len = (&columns - 30) / 2
            let buf_str = repeat(' ', buffer_str_len)
            let g:startify_custom_header = [
                \ buf_str . ' __     __  ______  __       __ ',
                \ buf_str . '|  \   |  \|      \|  \     /  \',
                \ buf_str . '| $$   | $$ \$$$$$$| $$\   /  $$',
                \ buf_str . '| $$   | $$  | $$  | $$$\ /  $$$',
                \ buf_str . ' \$$\ /  $$  | $$  | $$$$\  $$$$',
                \ buf_str . '  \$$\  $$   | $$  | $$\$$ $$ $$',
                \ buf_str . '   \$$ $$   _| $$_ | $$ \$$$| $$',
                \ buf_str . '    \$$$   |   $$ \| $$  \$ | $$',
                \ buf_str . '     \$     \$$$$$$ \$$      \$$',
                \]
        endif

        let g:startify_lists = [
            \ { 'header': ['   RECENT'],            'type': 'files' },
            \ { 'header': ['   SESSIONS'],       'type': 'sessions' },
        \ ]
    endif
    " }
    "
    " ryanoasis/vim-devicons {
    if HasPlug("vim-devicons")
        let g:webdevicons_enable_airline_statusline = 0
    endif
    " }
    "
    " simeji/winresizer {
    if HasPlug("winresizer")
        let g:winresizer_vert_resize  = 2
        let g:winresizer_horiz_resize = 2
        nnoremap <C-w>r :WinResizerStartResize<CR>
    endif
    " }

    " ludovicchabant/vim-gutentags {
    if HasPlug("vim-gutentags")
        if exists("*gutentags#statusline()")
            set statusline+=%{gutentags#statusline()}
        endif
        let g:gutentags_cache_dir=g:vim_dir . '/.vimtags/'
        let g:gutentags_project_root=['.git', '.hg', '.svn', '.bzr', '_darcs', '_FOSSIL_', '.fslckout', 'src']
    endif
    " }

    " easymotion/vim-easymotion {
    
        " <Leader>f{char} to move to {char}
        map  <Leader>f <Plug>(easymotion-bd-f)
        nmap <Leader>f <Plug>(easymotion-overwin-f)

        " s{char}{char} to move to {char}{char}
        nmap s <Plug>(easymotion-overwin-f2)

        " Move to line
        map <Leader>L <Plug>(easymotion-bd-jk)
        nmap <Leader>L <Plug>(easymotion-overwin-line)

        " Move to word
        map  <Leader>w <Plug>(easymotion-bd-w)
        nmap <Leader>w <Plug>(easymotion-overwin-w)

    " }

    " antoinemadec/coc-fzf {
    if HasPlug("coc-fzf")
        nnoremap <silent> <space><space> :<C-u>CocFzfList<CR>
        nnoremap <leader>o       :<C-u>CocFzfList outline<CR>
    endif
    " }
    
    " bling/vim-bufferline {
        let g:bufferline_echo = 0
        let g:bufferline_modified = '+'

        " scrolling with fixed current buffer position
        let g:bufferline_rotate = 0

        let g:bufferline_active_buffer_left = ''
        let g:bufferline_active_buffer_right = ''
        let g:bufferline_fixed_index = -1 
        let g:bufferline_inactive_highlight = 'StatusLineNC'
        let g:bufferline_active_highlight = 'StatusLine'
    
    " }

    " mbbill/undotree {
        nnoremap <leader>ut :UndotreeToggle<CR>
    " }

    " airblade/vim-rooter {
    if HasPlug("vim-rooter")
        let g:rooter_patterns = ['.vscode', '.git', '*.sln', 'src']
        let g:rooter_change_directory_for_non_project_files = 'current'
        let g:rooter_silent_chdir = 1
    endif
    " }
    
    " NerdTree {
        if (g:vim_type == 'vim' || g:vim_version < 0.8) && HasPlug('nerdtree')
            let g:NERDShutUp=1

            " work around for nerdtree bug: https://github.com/preservim/nerdtree/issues/1321
            let g:NERDTreeMinimalMenu = v:true
            let g:NERDTreeMinimalUI = v:true

            "nnoremap <C-e> :NERDTreeToggle<CR>
            function! NERDTreeFindToggle()
                let my_filetype = &filetype
                let specical_fts = ['nerdtree', 'startify']
                if  my_filetype == '' || index(specical_fts, my_filetype) >= 0
                    :NERDTreeToggle
                else
                    :NERDTreeFind
                endif
            endfunction
            nnoremap <silent> <leader>e :call NERDTreeFindToggle()<CR>

            "let NERDTreeShowBookmarks=1
            "let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
            let NERDTreeChDirMode        = 0
            let NERDTreeQuitOnOpen       = 1
            let NERDTreeMouseMode        = 2
            let NERDTreeShowHidden       = 1
            let NERDTreeKeepTreeInNewTab = 1

            " Exit Vim if NERDTree is the only window remaining in the only tab.
            autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif
        endif
    " }
    
    " nvim-tree.lua {
        if g:vim_type == 'nvim' && HasPlug("nvim-tree.lua")

            " Hide vim bottom statusline
            " autocmd FileType NvimTree setlocal noshowmode noruler laststatus=0 noshowcmd
            " set noshowmode noruler laststatus=0 noshowcmd
            " autocmd BufRead,BufNewFile NvimTree set laststatus=0 " This will work instead
        endif
    " }
     
    "if has('nvim') && str2float(g:nvim_version) >= 0.5 && HasPlug("lualine.nvim")
    " nvim-lualine/lualine.nvim {
    " }
    "else
    "
    " vim-airline {
    if g:vim_type == 'vim' && HasPlug("vim-airline")
        " Set configuration options for the statusline plugin vim-airline.
        " Use the powerline theme and optionally enable powerline symbols.
        
        " This must using my fork version of bufferline
        "
        let g:bufferline_max_length = &columns - 22
        function! BufferNumber()
            return len(g:index_to_buffer)
        endfunction
        call airline#parts#define_function('bufnum', 'BufferNumber')

        let g:airline_extensions = ['bufferline', 'filetype']
        let g:airline_section_x       = airline#section#create(['bufnum'])
        let g:airline_section_y       = ''
        let g:airline_section_z       = airline#section#create(['filetype'])
        let g:airline_skip_empty_sections = 1
        "let g:airline_exclude_filetypes = ['nerdtree'] " see source for current list
        let g:airline#extensions#nerdtree_statusline = 0
        "let g:airline#extensions#bufferline#overwrite_variables = 0
        let g:airline_mode_map = {
            \ '__'     : '-',
            \ 'c'      : 'C',
            \ 'i'      : 'I',
            \ 'ic'     : 'I',
            \ 'ix'     : 'I',
            \ 'n'      : 'N',
            \ 'multi'  : 'M',
            \ 'ni'     : 'N',
            \ 'no'     : 'N',
            \ 'R'      : 'R',
            \ 'Rv'     : 'R',
            \ 's'      : 'S',
            \ 'S'      : 'S',
            \ ''     : 'S',
            \ 't'      : 'T',
            \ 'v'      : 'V',
            \ 'V'      : 'V',
            \ ''     : 'V',
            \ }
        if HasPlug("vim-airline-themes/")
            "let g:airline_theme = 'solarized'
        endif
    endif
    " }
    "endif

    " junegunn/fzf {
        " [Buffers] Jump to the existing window if possible
        let g:fzf_buffers_jump = 1

        "let $FZF_DEFAULT_COMMAND='find . \( -name node_modules -o -name .git \) -prune -o -print'

        "   - Preview window on the right with 50% width
        "   - CTRL-/ will toggle preview window.
        let g:fzf_preview_window = ['right:50%', 'ctrl-/']


        " check if ripgrep is installed
        if ! executable('rg')
            command! -bang -nargs=* Rg
              \ call fzf#vim#grep(
              \   'grep -R --line-number --exclude-dir=".git;.svn" --color=always -- '.shellescape(<q-args>), 1,
              \   fzf#vim#with_preview(), <bang>0)
        endif
        noremap <leader><leader>r :Rg<CR>
        noremap <leader><leader>f :Files<CR>
    " }
    
    " neoclide/coc.nvim {
    if HasPlug("coc.nvim") && executable('node')
        " add desired extensions to the following global variable
        " coc-clangd: c/c++, may need to install clangd seperatly
        let g:coc_global_extensions = ['coc-pyright', 'coc-rls', 'coc-clangd', 'coc-tsserver', 'coc-html', 'coc-cmake', 'coc-json', 'coc-sh', 'coc-java']

        if filereadable(g:mydotfiles_directory . "/coc-nvim-config.vim")
            exec "source " . g:mydotfiles_directory . "/coc-nvim-config.vim"
        endif
        " warning that coc work best for vim >= 8.3
        let g:coc_disable_startup_warning = 1
    endif
    
    " }
" }

" Theme_Appearance
" {
"
    " debug function print out highlight group of cursor position
    function! SynStack()
      if !exists("*synstack")
        return
      endif
      echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
    endfunc

    nmap <Leader>db :call SynStack()<CR>

    " search and filter highlight group
    " :call Sh('airline')
    function! Sh(pattern)
        execute("filter /" . a:pattern . "/ highlight") 
    endfunc

    " dark or light
    if filereadable(g:vim_dir . '.light_theme.signal')
        let g:dark_or_white_theme = 'light'              
    else
        let g:dark_or_white_theme = 'dark'              
    endif

    " what to use for dark theme
    let g:dark_theme = 'default'               
    " let g:airline_dark_theme = "violet"               
    let g:airline_dark_theme = "angr"               

    " what to use for light theme
    let g:light_theme = 'default'              
    let g:airline_light_theme = "silver"               

    " transparent backgroud for supported terminal emulator
    " check if transparent_dark_theme.signl or transparent_light_theme.signl
    " exist and set respect variable
    let g:transparent_dark_theme = v:false     
    let g:transparent_light_theme = v:false     
    if filereadable(g:vim_dir . '.transparent_dark_theme.signal')
        let g:transparent_dark_theme = v:true     
    endif
    if filereadable(g:vim_dir . '.transparent_light_theme.signal')
        let g:transparent_light_theme = v:true     
    endif

    function! SetDarkTheme()
        set background=dark
        hi clear
        execute("colorscheme " . g:dark_theme)
        let g:dark_or_white_theme = 'dark'
    endfunction

    function! SetLightTheme()
        set background=light
        hi clear
        execute("colorscheme " . g:light_theme)
        let g:dark_or_white_theme = 'light'
    endfunction

    " Change bottom airline/lualine theme
    " Currently only support airline
    function! SetAirlineTheme(theme)
        if g:vim_type == 'nvim' && g:vim_version >= 0.5
            "execute('AirlineTheme ' . a:theme)
        else
            execute('AirlineTheme ' . a:theme)
        endif
    endfunction

    " Fix colorscheme not working correctly under transparent background
    " There is no plugin for this for nvim < 0.5 or vim without lua support
    function! TransparentBackgroundFix()
        if !has('nvim') || g:vim_version < 0.5
        " if v:true
        " if v:true
            highlight CursorLineNr ctermbg=none
            highlight SignColumn ctermbg=none
            if v:false
                "highlight CursorLineNr ctermbg=none
                highlight CocWarningHighlight ctermbg=none
                highlight CocErrorSign ctermbg=none ctermfg=9 cterm=bold
                highlight CocErrorHighlight ctermbg=none ctermfg=9 cterm=underline,bold
                highlight CocInfoHighlight ctermbg=none
                highlight CocHintHighlight ctermbg=none
                highlight CocWarningSign ctermbg=none
                highlight CocInfoSign    ctermbg=none
                highlight CocHintSign    ctermbg=none
                if g:dark_or_white_theme == 'dark'
                    highlight! link TempColor Visual
                    highlight! link CocFloating     TempColor
                    highlight! link CocErrorFloat   TempColor
                    highlight! link CocWarningFloat TempColor
                    highlight! link CocInfoFloat    TempColor
                    highlight! link CocHintFloat    TempColor
                endif
            endif
        endif
    endfunction

    function! EnableTransparent()
        if g:vim_type == 'nvim' && g:vim_version > 0.5
            :TransparentEnable
        else
            if g:dark_or_white_theme == 'dark'
                let g:PaperColor_Theme_Options = {
                \   'theme': {
                \       'default.dark': {
                \           'transparent_background': 1
                \        }
                \   }
                \ }
                execute("colorscheme " . g:dark_theme)
            elseif g:dark_or_white_theme == 'light'
                let g:PaperColor_Theme_Options = {
                \   'theme': {
                \       'default.light': {
                \           'transparent_background': 1
                \        }
                \   }
                \ }
                execute("colorscheme " . g:light_theme)
            endif
        endif
        call TransparentBackgroundFix()
    endfunction

    function! DisableTransparent()
        if g:vim_type == 'nvim' && g:vim_version > 0.5
            :TransparentDisable
        else
            if g:dark_or_white_theme == 'dark'
                let g:PaperColor_Theme_Options = {
                \   'theme': {
                \       'default.dark': {
                \           'transparent_background': 0
                \        }
                \   }
                \ }
                execute("colorscheme " . g:dark_theme)
            elseif g:dark_or_white_theme == 'light'
                let g:PaperColor_Theme_Options = {
                \   'theme': {
                \       'default.light': {
                \           'transparent_background': 0
                \        }
                \   }
                \ }
                execute("colorscheme " . g:light_theme)
            endif
        endif
    endfunction

    " delete signal file if exist
    function! DeleteSignalFile(name)
        if filereadable(g:vim_dir . a:name)
            call delete(g:vim_dir . a:name)
        endif
    endfunction
    
    " Create signal file if not exist
    function! CreateSignalFile(name)
        call system("touch " . g:vim_dir . a:name)
    endfunction

    " ToggleTransparent background
    " only works in dark theme
    function! ToggleTransparent()
        if g:transparent_dark_theme && g:dark_or_white_theme == 'dark'
            call DisableTransparent()
            let g:transparent_dark_theme = v:false     
            call DeleteSignalFile('.transparent_dark_theme.signal')
        elseif g:transparent_light_theme && g:dark_or_white_theme == 'light'
            call DisableTransparent()
            let g:transparent_light_theme = v:false     
            call DeleteSignalFile('.transparent_light_theme.signal')
        else
            call EnableTransparent()
            if g:dark_or_white_theme == 'dark'
                let g:transparent_dark_theme = v:true     
                call CreateSignalFile('.transparent_dark_theme.signal')
            else
                let g:transparent_light_theme = v:true     
                call CreateSignalFile('.transparent_light_theme.signal')
            endif
        endif
    endfunction


    " vim theme 
    if !has('nvim') && HasPlug("papercolor-theme") && HasPlug('papercolor-theme')
        set t_Co=256
        " improve coc color in this theme
        let g:light_theme = 'PaperColor'              
        let g:dark_theme = 'PaperColor'
        "let g:airline_dark_theme = "papercolor"               
        "let g:airline_light_theme = "papercolor"               
    endif

        " nvim only theme
    if has('nvim')
        if g:vim_version >= 0.8 && HasPlug("nightfox.nvim")
            let g:light_theme = 'dawnfox'
            "let g:dark_theme = 'nightfox'
        end   

        if g:vim_version >= 0.5 && HasPlug("/github-nvim-theme")
            let g:dark_theme = 'github_dark'
            " let g:dark_theme = 'github_dark_default'
            " let g:dark_theme = 'github_dimmed'
            let g:airline_dark_theme = "hybrid"               
        end
    endif
   
   
    if g:dark_or_white_theme == 'dark'
        let g:airline_theme=g:airline_dark_theme
        call SetDarkTheme()
    else
        let g:airline_theme=g:airline_light_theme
        call SetLightTheme()
    endif

    " Since in .vimrc we cannot call plugin function as they
    " are not loaded (:help startup)
    if (g:transparent_dark_theme && g:dark_or_white_theme == 'dark') || (g:transparent_light_theme && g:dark_or_white_theme == 'light')
        if g:vim_type == 'nvim' && g:vim_version > 0.5
            let g:transparent_enabled = v:true
        else
            call EnableTransparent()
        endif
        call TransparentBackgroundFix()
    else 
        if g:vim_type == 'nvim' && g:vim_version > 0.5
            let g:transparent_enabled = v:false
        else
            call DisableTransparent()
        endif
    endif
        
    " Allow to trigger background
    function! ToggleBG()
        " Inversion
        if g:dark_or_white_theme == "dark"
            call SetLightTheme()
            call SetAirlineTheme(g:airline_light_theme)
            call CreateSignalFile('.light_theme.signal') 
        else
            call SetDarkTheme()
            call SetAirlineTheme(g:airline_dark_theme)
            " for saving theme state
            call DeleteSignalFile(".light_theme.signal")
        endif

        if g:transparent_dark_theme && g:dark_or_white_theme == 'dark' || g:transparent_light_theme && g:dark_or_white_theme == 'light'
            call EnableTransparent()
        else
            call DisableTransparent()
        endif
    endfunction

" }

" Key_Mappings
" (This doesn't include plugin specific mapping.
" For them please check plugin Preferences)
" {

    " Toggle dark/light theme
    noremap <silent> <leader>bg :call ToggleBG()<CR>

    " Toggle transparent background
    noremap <silent> <leader>tb :call ToggleTransparent()<CR>

    " Buffer navigation
    nnoremap <silent> <space>q :bprevious<CR>
    nnoremap <silent> <space>e :bnext<CR>

    " leader s change all occurence
    nnoremap <silent> <Leader>s :%s/\<<C-r><C-w>\>/

    " leader num change tab
    " only for vim or nvim without lualine
    if g:vim_type == 'vim' || (g:vim_type == 'nvim' && g:vim_version < 0.5)
        " nnoremap <Leader>1 :b1<CR>
        " nnoremap <Leader>2 :b2<CR>
        " nnoremap <Leader>3 :b3<CR>
        " nnoremap <Leader>4 :b4<CR>
        " nnoremap <Leader>5 :b5<CR>
        " nnoremap <Leader>6 :b6<CR>
        " nnoremap <Leader>7 :b7<CR>
        " nnoremap <Leader>8 :b8<CR>
        " nnoremap <Leader>9 :b9<CR>
        nnoremap <silent> <nowait> <Leader>1 :call bufferline#jump(1)<CR>
        nnoremap <silent> <nowait> <Leader>2 :call bufferline#jump(2)<CR>
        nnoremap <silent> <nowait> <Leader>3 :call bufferline#jump(3)<CR>
        nnoremap <silent> <nowait> <Leader>4 :call bufferline#jump(4)<CR>
        nnoremap <silent> <nowait> <Leader>5 :call bufferline#jump(5)<CR>
        nnoremap <silent> <nowait> <Leader>6 :call bufferline#jump(6)<CR>
        nnoremap <silent> <nowait> <Leader>7 :call bufferline#jump(7)<CR>
        nnoremap <silent> <nowait> <Leader>8 :call bufferline#jump(8)<CR>
        nnoremap <silent> <nowait> <Leader>9 :call bufferline#jump(9)<CR>
        nnoremap <silent> <nowait> <Space>10 :call bufferline#jump(10)<CR>
        nnoremap <silent> <nowait> <Space>11 :call bufferline#jump(11)<CR>
        nnoremap <silent> <nowait> <Space>12 :call bufferline#jump(12)<CR>
        nnoremap <silent> <nowait> <Space>13 :call bufferline#jump(13)<CR>
    end

    " split window comform with other window management shortcuts
    nnoremap <silent> <C-w>% :vsplit<CR>
    nnoremap <silent> <C-w>" :split<CR>

    " session related KeyBinding. These KeyBinding uses function from startify
    nnoremap <silent> <leader><leader>s :SSave<CR>
    nnoremap <silent> <leader><leader>l :SLoad<CR>
    nnoremap <silent> <leader><leader>d :SDelete!<CR>
    nnoremap <silent> <leader><leader>c :SClose<CR>
    
" }
"
" Lua configuration
    if g:vim_type == 'nvim' && filereadable(g:mydotfiles_directory . '.vimrc.lua')
        execute('source ' . g:mydotfiles_directory . '/.vimrc.lua')
    endif
"   
" Useful_Info{
"   show mapping info
"   :verbose map ,cf
" }

if filereadable(g:mydotfiles_directory . "/config/theme.vim")
    exec "source " . g:mydotfiles_directory . "/config/theme.vim"
endif
