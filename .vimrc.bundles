" (jump to the topic)
"
" OPTIONS
" PLUGIN_INSTALL
" UTILITIES
" PLUGIN_CONFIGURATION " THEME_CONFIGURATION
" KEY_MAPS
" OTHER_CONFIGS

let g:debug_mode = v:false
let g:high_performence = v:false                 " set true will also disable animation
let g:autocomplte_enable = v:true
let g:copilot_enable = v:false

" only in nvim (using which-key)
let g:key_prompt = v:false

" only used by neovim
let g:classic_vim_ui = v:true
let g:animation_enable = v:true

let g:swap_dict = [
    \ ['v:false', '0', 'dark', 'false' ],
    \ ['v:true' , '1', 'light', 'true']]
" convinient function to swap between two options
nmap <leader><leader>t :call SwapWord()<CR>

"""""" PLUGIN_INSTALL """"""

let g:dotfiledir = expand('~/.dotfiles/')
let g:plugin_dir = expand('~/.vim/plugged/')
let g:config_file_path = g:vim_dir . ".config.vim"
call plug#begin(g:plugin_dir)
    " https://github.com/junegunn/vim-plug/wiki/tips
    function! Cond(cond, ...)
      let opts = get(a:000, 0, {})
      return a:cond ? opts : extend(opts, { 'on': [], 'for': [] })
    endfunction
    let g:animation_enable = g:high_performence ? v:false : g:animation_enable

    " custom plugin
    Plug 'Donaldttt/fzf-color-preview', Cond(g:vim_v >= 800)

    """" THEME_PLUGINS """"

    Plug 'sainnhe/everforest'
    if !g:high_performence
        Plug 'bluz71/vim-moonfly-colors', { 'as': 'moonfly' }
        Plug 'jacoborus/tender.vim'
        Plug 'cocopon/iceberg.vim'
        Plug 'catppuccin/nvim', Cond( has('nvim-0.8.2')  \|\| g:vim_v >= 900  , { 'as': 'catppuccin' })
        Plug 'NLKNguyen/papercolor-theme'
        Plug 'EdenEast/nightfox.nvim', Cond(has('nvim-0.5'))
        Plug 'projekt0n/github-nvim-theme', Cond(has('nvim-0.5'), { 'tag': 'v0.0.7' })
        Plug 'folke/tokyonight.nvim', Cond(g:vim_type == 'nvim', { 'branch': 'main' })
    endif

    """""""" END """"""""""
    Plug 'lervag/vimtex'
    Plug 'github/copilot.vim', Cond(( g:vim_type == 'nvim' \|\| g:vim_v >= 900 )
        \ && g:copilot_enable && executable('node'))

    Plug 'gelguy/wilder.nvim', Cond((g:vim_type == 'vim' \|\| g:classic_vim_ui) && !g:high_performence)
    "     " To use Python remote plugin features in Vim for wilder, can be skipped
    "     " Plug 'roxma/nvim-yarp', Cond(g:vim_type == 'vim')
    Plug 'roxma/vim-hug-neovim-rpc', Cond(g:vim_v >= 800 && has('python3'))

    Plug 'dstein64/vim-startuptime', Cond(!g:high_performence)
    Plug 'simeji/winresizer', Cond(!g:high_performence)
    Plug 'rust-lang/rust.vim', { 'for': ['rust'] }

    Plug 'machakann/vim-sandwich'
    Plug 'rhysd/conflict-marker.vim'

    Plug 'jiangmiao/auto-pairs'
    " Plug 'mg979/vim-visual-multi'
    Plug 'RRethy/vim-illuminate', Cond(!g:high_performence)
    "Plug 'easymotion/vim-easymotion'
    Plug 'mhinz/vim-startify'
    " Plug 'ludovicchabant/vim-gutentags'

    Plug 'christoomey/vim-tmux-navigator'
    Plug 'airblade/vim-rooter'
    Plug 'roxma/vim-tmux-clipboard', Cond(executable('tmux'))
    Plug 'liuchengxu/vista.vim', Cond(!g:high_performence)

    "" ESSENTIAL_PLUGINS ""

    " Comment stuff out
    Plug 'tpope/vim-commentary'
    Plug 'vim-scripts/restore_view.vim'

    " vim only plugins
    Plug 'scrooloose/nerdtree', Cond(g:vim_type == 'vim' \|\| !has('nvim-0.8'), { 'on' : ['NERDTreeToggle', 'NERDTreeFind'] })
    Plug 'tiagofumo/vim-nerdtree-syntax-highlight', Cond(g:vim_type == 'vim' && !g:high_performence)

    Plug 'neoclide/coc.nvim', Cond(g:autocomplte_enable && executable('node'), {'branch': 'release'})

    " only work with vim
    if g:vim_type == 'vim'
        Plug 'voldikss/vim-floaterm', Cond(has('terminal'))
        set encoding=UTF-8
        if executable('fzf')
            Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
            Plug 'junegunn/fzf.vim'
            Plug 'antoinemadec/coc-fzf'
        endif

        Plug 'vim-airline/vim-airline'
        Plug 'vim-airline/vim-airline-themes'
        Plug 'Donaldttt/vim-bufferline'
        Plug 'ryanoasis/vim-devicons'
        Plug 'wfxr/minimap.vim', Cond(executable('code-minimap'), {'on' : ['MinimapToggle']})
    endif

    if g:vim_type == 'nvim'
        if g:vim_version >= 0.5
            Plug 'xiyaowong/nvim-transparent'
            Plug 'lukas-reineke/indent-blankline.nvim', Cond(!g:animation_enable)
            Plug 'echasnovski/mini.indentscope', Cond(g:animation_enable)
            Plug 'echasnovski/mini.animate', Cond(g:animation_enable)

            Plug 'nvim-lualine/lualine.nvim'
            Plug 'karb94/neoscroll.nvim', Cond(g:animation_enable)
            Plug 'petertriho/nvim-scrollbar', Cond(g:animation_enable)
            Plug 'folke/which-key.nvim', Cond(!g:high_performence && g:key_prompt)
        endif
        if g:vim_version >= 0.7
            Plug 'nvim-treesitter/nvim-treesitter', Cond(executable('make'), {'do': ':TSUpdate'})

            " for telescope
            Plug 'nvim-lua/plenary.nvim'
            Plug 'nvim-telescope/telescope.nvim', Cond(g:vim_type == 'nvim', { 'branch': '0.1.x' })
            " c plugin for telescope to make it faster
            Plug 'nvim-telescope/telescope-fzf-native.nvim', Cond(executable('make'), { 'do': 'make' })

            " comment out this plugin if the machine doesn't have required
            " font install
            Plug 'nvim-tree/nvim-web-devicons'
            Plug 'akinsho/toggleterm.nvim', Cond(g:vim_type == 'nvim', {'tag' : '*'})
        endif
        if g:vim_version >= 0.8
            Plug 'nvim-tree/nvim-tree.lua'

            Plug 'rcarriga/nvim-notify', Cond(!g:high_performence && !g:classic_vim_ui)
            Plug 'folke/noice.nvim', Cond(!g:high_performence && !g:classic_vim_ui)
            Plug 'MunifTanjim/nui.nvim', Cond(!g:high_performence && !g:classic_vim_ui)
        endif
    endif

call plug#end()

augroup InitConfig
    autocmd VimLeave * call SaveConfig()

    " Automatically install missing plugins at startup
    autocmd VimEnter *
        \  if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
        \|   PlugInstall --sync | q
        \| endif
augroup end

"""""" UTILITIES """"""

" import ultilities functions
execute('source ' . g:dotfiledir . '/utils.vim')

function! SaveConfig()
    let p = ReadVariable(g:config_file_path)
    if type(p) != type({})
        let p = {}
    endif

    let config = has_key(p, g:vim_type) && type(p[g:vim_type]) == 4
        \ ? p[g:vim_type] : {}
    let config = Merge(config, g:my_config)

    " vim and nvim may have diferenrt available plugins
    let p[g:vim_type] = config
    call SaveVariable(p, g:config_file_path)
endfunction

function! LoadConfig()
    let result = ReadVariable(g:config_file_path)
    " if it is dictionary
    if type(result) == 4
        if has_key(result, g:vim_type)
            let config = result[g:vim_type]
            if type(config) == 4 | return config | endif
        endif
    endif
    return {}
endfunction

""""""" PLUGIN_CONFIGURATION """"""

" a list of funcref that will be initilized late
let s:post_init_func = []
function s:registerLateInit(func)
    let Funcref = type(a:func) == 10 ? func : function(a:func)
    call add(s:post_init_func, Funcref)
endfunction

function s:executeLateInit()
    function s:lateInitHelper(...)
        for Funcref in s:post_init_func
            call Funcref()
        endfor
    endfunction
    autocmd VimEnter * call timer_start(1, function('s:lateInitHelper'))
endfunction

if HasPlug('vim-floaterm')
    let g:floaterm_wintype = 'float'
    let g:floaterm_keymap_toggle = '<C-\>'
    let g:floaterm_position = 'bottomright'
    let g:floaterm_width = 0.5
    let g:floaterm_height = 0.5
    autocmd QuitPre * :FloatermKill!<CR>
    autocmd FileType floaterm tmap <buffer> <C-[> <C-\><C-n>
endif
if HasPlug('Copilot.vim')
    " imap <expr> <C-n> <Plug>(copilot-next)
    " imap <expr> <C-p> <Plug>(copilot-prev)
endif

if HasPlug('vimtex')
    if g:os == 'Darwin'
        let g:vimtex_view_method = 'skim'
    endif
    nmap <leader>lv <plug>(vimtex-view)
    nmap <leader>lc :VimtexCompile<CR>
    let g:vimtex_quickfix_open_on_warning = 0
endif
if HasPlug('minimap.vim')
    nnoremap <silent> <leader>mm :MinimapToggle<CR>
    let g:minimap_highlight_search = 1
    let g:minimap_git_colors = 1
    let g:minimap_enable_highlight_colorgroup = 1
    let g:minimap_block_filetypes = ['help', 'nerdtree']
endif

if HasPlug('vista.vim')
    let g:vista_default_executive = 'vim_lsp'
    if HasPlug('coc.nvim')
        let g:vista_default_executive = 'coc'
    elseif HasPlug('coc.nvim')
        let g:vista_default_executive = 'ctags'
    endif
    nnoremap <silent> <leader>v :Vista!!<CR>
    let g:vista_cursor_delay = 0
    let g:vista_echo_cursor = 0
    let g:vista_echo_cursor_strategy = 'floating_win'
    let g:vista_close_on_jump = 0
    let g:vista_floating_delay = 0
    let g:vista_ignore_kinds = ['Variable', 'Field', 'EnumMember',
                \ 'String', 'Object', 'Array', 'Constant', 'Package', 'Boolean', 'Number'
                \ ]
    let g:vista_floating_border = 'rounded'
    let g:vista_disable_statusline = 1
    " let g:vista_keep_fzf_colors = 1
    let g:vista_update_on_text_changed_delay = 0
    let g:vista_update_on_text_changed = 1
    let g:vista#renderer#enable_kind = 1
    let g:vista#renderer#enable_icon = 1

    " return to last position of vista
    let g:vista_last_row = v:null
    function VistaCursorJump()
        " let found = vista#util#BinarySearch(g:vista.raw, line('.'), 'line', '')
        let found = g:vista_last_row
        if empty(found)
            return
        endif
        let vlnum = get(found, 'vlnum', v:null)
        call cursor(vlnum, 3)
    endfunction

    " save tag for VistaCursorJump use
    function VistaH2()
        if exists('*vista#util#BinarySearch')
            let bufs = map(filter(copy(getbufinfo()), 'v:val.listed'), 'v:val.bufnr')
            if index(bufs, bufnr('%')) < 0
                return
            endif
            let found = vista#util#BinarySearch(g:vista.raw, line('.'), 'line', '')
            if empty(found)
                return
            endif
            let g:vista_last_row = found
        endif
    endfunction
    autocmd BufLeave * call VistaH2()
    autocmd FileType vista call VistaCursorJump()

endif

if HasPlug('indentLine')
    let g:indentLine_fileTypeExclude = ['startify']
endif

if HasPlug('vim-illuminate') && g:vim_type == 'vim' " nvim doesn't need this config
    let g:Illuminate_ftHighlightGroups = {
    \ 'vim:blacklist': ['vimLet', 'vimFuncKey', 'vimNotFunc', 'vimOperParen', 'vimLineComment'],
    \ 'java:blacklist' : [ 'javaType', 'javaScopeDecl', 'javaMethodDecl',
    \ 'javaComment', 'javaStorageClass', 'javaClassDecl', 'javaExternal',
    \ 'javaTypedef', 'javaLineComment', 'javaStatement', 'javaCommentTitle', 'javaDocComment' ],
    \ 'lua:blacklist' : [ 'luaComment', 'luaCond', 'luaStatement', 'luaFunction' ]
    \ }
    let g:Illuminate_ftwhitelist = ['vim', 'sh', 'python', 'rust', 'java',
        \ 'c', 'cpp', 'javascript', 'typescript', 'lua']

    " ugly workaround for the bug that illuminate not working after first
    " enter vim
    function s:init_illuminate(...)
        hi illuminatedWord cterm=underline gui=underline
    endfunction

    call s:registerLateInit('s:init_illuminate')
    augroup illuminate_augroup
        autocmd!
        autocmd ColorScheme * hi illuminatedWord cterm=underline gui=underline
    augroup END

endif

if HasPlug('wilder.nvim')

    call wilder#setup({
        \ 'modes': [':'],
        \ 'next_key': '<tab>',
        \ 'previous_key': '<S-Tab>',
        \ 'enable_cmdline_enter': 0,
        \ })

    call wilder#set_option('pipeline', [
        \   wilder#debounce(10),
        \   wilder#branch(
        \     wilder#cmdline_pipeline({'language': g:vim_type == 'nvim' ? 'python' : 'vim'}),
        \   ),
        \ ])

    if g:vim_type == 'vim'
        call wilder#set_option('renderer', wilder#popupmenu_renderer())
    else
        call wilder#set_option('renderer', wilder#popupmenu_renderer(
            \ wilder#popupmenu_border_theme({
            \ 'highlights': {
            \   'default': 'Normal',
            \ },
            \ 'pumblend': 20,
            \ 'border': 'rounded',
            \ })))
    endif
endif

if HasPlug('vim-tmux-navigator')
    let g:tmux_navigator_no_mappings = 1

    noremap <silent> <c-h> :<C-U>TmuxNavigateLeft<cr>
    noremap <silent> <c-j> :<C-U>TmuxNavigateDown<cr>
    noremap <silent> <c-k> :<C-U>TmuxNavigateUp<cr>
    noremap <silent> <c-l> :<C-U>TmuxNavigateRight<cr>
    " noremap <silent> {Previous-Mapping} :<C-U>TmuxNavigatePrevious<cr>
endif

if HasPlug("vim-startify")
    if g:vim_type == 'nvim'
        let buffer_str_len = (&columns - 60) / 2
        let g:startify_custom_header = GenVimAsciiArt(buffer_str_len)
    else
        let buffer_str_len = (&columns - 30) / 2
        let g:startify_custom_header = GenVimAsciiArt(buffer_str_len)
    endif

    let g:startify_lists = [
        \ { 'header': ['   RECENT'],            'type': 'files' },
        \ { 'header': ['   SESSIONS'],       'type': 'sessions' },
    \ ]

    " session related KeyBinding. These KeyBinding uses function from startify
    nnoremap <silent> <leader><leader>s :SSave!<CR>
    nnoremap <silent> <leader><leader>l :SLoad<CR>
    nnoremap <silent> <leader><leader>d :SDelete!<CR>
    nnoremap <silent> <leader><leader>c :SClose<CR>

endif

if HasPlug("vim-devicons")
    let g:webdevicons_enable_airline_statusline = 0
endif

if HasPlug("winresizer")
    let g:winresizer_vert_resize  = 2
    let g:winresizer_horiz_resize = 2
    " nnoremap <C-w>r :WinResizerStartResize<CR>
    let g:winresizer_start_key = '<C-w>r'
endif

if HasPlug("vim-gutentags")
    if exists("*gutentags#statusline()")
        set statusline+=%{gutentags#statusline()}
    endif
    let g:gutentags_trace = 1
    let g:gutentags_cache_dir=g:vim_dir . '/.vimtags/'
    let g:gutentags_project_root=['.git', '.hg', '.svn', '.bzr', '_darcs', '_FOSSIL_', '.fslckout', 'src']
endif

if HasPlug("vim-easymotion")
    " <Leader>f{char} to move to {char}
    map  <Leader>f <Plug>(easymotion-bd-f)
    nmap <Leader>f <Plug>(easymotion-overwin-f)

    " s{char}{char} to move to {char}{char}
    nmap s <Plug>(easymotion-overwin-f2)

    " Move to line
    map <Leader>L <Plug>(easymotion-bd-jk)
    nmap <Leader>L <Plug>(easymotion-overwin-line)

    " Move to word
    map  <Leader>w <Plug>(easymotion-bd-w)
    nmap <Leader>w <Plug>(easymotion-overwin-w)
endif

if HasPlug("coc-fzf")
    " nnoremap <silent> <space><space> :<C-u>CocFzfList<CR>
    " nnoremap <leader>o       :<C-u>CocFzfList outline<CR>
endif

if HasPlug("vim-bufferline") && HasPlug("vim-airline")
    let g:bufferline_echo = 0
    let g:bufferline_modified = '+'

    " scrolling with fixed current buffer position

    let g:bufferline_active_buffer_left = '['
    let g:bufferline_active_buffer_right = ']'
    let g:bufferline_inactive_highlight = 'airline_c'
    let g:bufferline_active_highlight = 'airline_c_bold'
endif

if HasPlug("undotree")
    nnoremap <leader>ut :UndotreeToggle<CR>
endif

if HasPlug("vim-rooter")
    let g:rooter_patterns = ['.vscode', '.git', '*.sln', 'src']
    let g:rooter_change_directory_for_non_project_files = 'current'
    let g:rooter_silent_chdir = 1
endif

if (g:vim_type == 'vim' || g:vim_version < 0.8) && HasPlug('nerdtree')
    if HasPlug('vim-nerdtree-syntax-highlight')
        let g:NERDTreeLimitedSyntax = 1
    endif
    let g:NERDShutUp=1

    " work around for nerdtree bug: https://github.com/preservim/nerdtree/issues/1321
    let g:NERDTreeMinimalMenu = v:true
    let g:NERDTreeMinimalUI = v:true

    function! NERDTreeEchoPathHandler(node)
        echo a:node.path.str()
    endfunction

   autocmd! User nerdtree call NERDTreeAddKeyMap({
           \ 'key': 'p',
           \ 'callback': 'NERDTreeEchoPathHandler',
           \ 'quickhelpText': 'echo full path of current node',
           \ 'scope': 'Node' })

    function! NERDTreeFindToggle()
        let my_filetype = &filetype
        let specical_fts = ['nerdtree', 'startify']
        if  my_filetype == '' || index(specical_fts, my_filetype) >= 0
            :NERDTreeToggle
        else
            :NERDTreeFind
        endif
    endfunction
    nnoremap <silent> <leader>e :call NERDTreeFindToggle()<CR>

    "let NERDTreeShowBookmarks=1
    "let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
    let NERDTreeChDirMode        = 0
    let NERDTreeQuitOnOpen       = 1
    let NERDTreeMouseMode        = 2
    let NERDTreeShowHidden       = 1

    if HasPlug('vim-devicons') || HasPlug('nerdfont.vim')
        let NERDTreeDirArrowCollapsible = ''
        let NERDTreeDirArrowExpandable = ''
    else
        " let NERDTreeDirArrowCollapsible = ''
        " let NERDTreeDirArrowExpandable = ''
    endif
    " Exit Vim if NERDTree is the only window remaining in the only tab.
    autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif
endif

if HasPlug("vim-airline")

    " Set configuration options for the statusline plugin vim-airline.
    " Use the powerline theme and optionally enable powerline symbols.

    " TODO
    " 22 is a magic number, it is best it can change as buffer width
    " changing

    " This must use my fork version of bufferline
    " the number of cols bufferline cannot use out of max of screen cols
    let g:bufferline_forbided_col = 32
    call airline#parts#define_function('bufnum', 'AirlineBufferNumber')
    call airline#parts#define_function('cocstatus', 'AirlineCocStatus')
    call airline#parts#define_accent('cocstatus', 'italic')
    call airline#parts#define_accent('bufnum', 'bold')
    call airline#parts#define_accent('bufnum', 'italic')
    call airline#parts#define_accent('filetype', 'italic')

    let g:airline_experimental = g:vim_v >= 900 ? 1 : 0

    function! AirlineInit()
        let _airline_section_y = ''
        if HasPlug('coc.nvim')
            let _airline_section_y = airline#section#create(['cocstatus'])
        endif
        " this create function returns a format string for status line (:h
        " stl). the string we append is what will happend if we pass
        " cocstatus into the create function. By appending them we have
        " more freedom format the highlight
        " let g:airline_section_y       = '%{%airline#util#wrap(AirlineCocStatus(), 0)%}'
        let g:airline_section_a       = airline#section#create(['mode'])
        let g:airline_section_b       = ''
        let g:airline_section_error   = ''
        let g:airline_section_warning = ''
        " let g:airline_section_x       = airline#section#create(['bufnum'])
        let g:airline_section_x       = ''
        let g:airline_section_y       = _airline_section_y
        let g:airline_section_z       = airline#section#create(['filetype'])
        " see source for current list
        function s:airline_refresh(timer)
            :AirlineRefresh!
        endfunction

        autocmd! CursorMoved * call s:airline_refresh(0)

    endfunction

    function! s:airlineconfig()
        " TODO
        " the problem is that colorscheme command will trigger this function
        " and at that time background=new but airline_theme=old
        " Right now I decide to modify airline them first and if the
        " colorscheme has it's own ariline theme it will override user
        " choice.
        " call add(g:msgs, g:ccc)
        " call add(g:msgs, g:airline_theme)
        " call add(g:msgs, &background)
        " let g:my_config[&background].airline_theme = g:airline_theme
    endfunction

    augroup AirlineAu
        autocmd!
        autocmd User AirlineAfterTheme  call s:airlineconfig()
        autocmd User AirlineAfterInit call AirlineInit()
    augroup end

    let g:airline#extensions#localsearch#enabled = 0
    let g:airline_extensions = ['bufferline']
    let g:airline_exclude_filetypes = ['vista', 'minimap']
    let g:airline_skip_empty_sections = 1
    " without this airline will overwrite some setting like bufferline_active_buffer_left, etc.
    let g:airline#extensions#bufferline#overwrite_variables = 0
    let g:airline_mode_map = {
        \ '__'     : '-',
        \ 'c'      : 'C',
        \ 'i'      : 'I',
        \ 'ic'     : 'I',
        \ 'ix'     : 'I',
        \ 'n'      : 'N',
        \ 'multi'  : 'M',
        \ 'ni'     : 'N',
        \ 'no'     : 'N',
        \ 'R'      : 'R',
        \ 'Rv'     : 'R',
        \ 's'      : 'S',
        \ 'S'      : 'S',
        \ ''     : 'S',
        \ 't'      : 'T',
        \ 'v'      : 'V',
        \ 'V'      : 'V',
        \ ''     : 'V',
        \ }

endif

if HasPlug("fzf") && HasPlug("fzf.vim")
    " [Buffers] Jump to the existing window if possible
    let g:fzf_buffers_jump = 1
    "let $FZF_DEFAULT_COMMAND='find . \( -name node_modules -o -name .git \) -prune -o -print'

    "   - CTRL-/ will toggle preview window.
    if g:os == 'Windows'
        let g:fzf_preview_window = []
    else
        let g:fzf_preview_window = ['right:50%']
    end

    let g:fzf_colors = {
        \ 'gutter':      ['bg', 'Normal'],
        \ }

    " check if ripgrep is installed
    if ! executable('rg')
        command! -bang -nargs=* Rg
          \ call fzf#vim#grep(
          \   'grep -R --line-number --exclude-dir=".git;.svn" --color=always -- '.shellescape(<q-args>), 1,
          \   fzf#vim#with_preview(), <bang>0)
    endif

    command! -bang -nargs=* CFile
      \ call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case --vimgrep -- "
      \ .shellescape(<q-args>). " ".expand('%'),
      \ 1, fzf#vim#with_preview(), <bang>0)

    function! FzfColorSelect(color_name)
        execute("colorscheme " . a:color_name)
        let g:my_config.background = &background
        let g:my_config[&background].theme = a:color_name
        if has_key(g:colo2airline, a:color_name )
            call SetStatusLineTheme(&background, g:colo2airline[a:color_name])
        endif
    endfunction

    function! FzfAirlineColorSelect(color_name)
        call SetStatusLineTheme(&background, a:color_name)
    endfunction
    let g:VimrpcFzfColor = function('FzfColorSelect')
    let g:VimrpcFzfAirline = function('FzfAirlineColorSelect')

    noremap <leader>fr :Rg<CR>
    noremap <leader>ff :Files<CR>
    noremap <leader>ft :CFile<CR>
    noremap <leader>fa :AirlinePreview<CR>
    noremap <leader>fc :ColorsPreview<CR>
endif

if HasPlug("coc.nvim") && executable('node')
    " coc-clangd: c/c++, may need to install clangd seperatly

    if filereadable(g:dotfiledir . "/coc-nvim-config.vim")
        exec "source " . g:dotfiledir . "/coc-nvim-config.vim"
    endif
    " warning that coc work best for vim >= 8.3
    let g:coc_disable_startup_warning = 1
endif

"""""" THEME_CONFIGURATION """"""
    " GOTO menu
    " THEME_README
    " THEME_PLUGINS_CONFIG
    " THEME_ULTILITIES
    " THEME_INIT            " Setup theme when vim first start
    " THEME_OPTIONS

    """ THEME_README """

    " set custom callback functions to use when when enabling/diabling transparent
    " for certain colorscheme
    "     let g:light_transparent_enable_cb = ''
    "     let g:light_transparent_disable_cb = ''
    "     let g:dark_transparent_enable_cb = ''
    "     let g:dark_transparent_disable_cb = ''

    """ THEME_PLUGINS_CONFIG """

    if HasPlug('nvim-transparent')

        " generic nvim transparent enable and disable function
        function Nvim_TB_enable()
            :TransparentEnable
        endfunction
        function Nvim_TB_disable()
            :TransparentDisable
        endfunction

        let g:light_transparent_enable_cb = 'Nvim_TB_enable'
        let g:light_transparent_disable_cb = 'Nvim_TB_disable'
        let g:dark_transparent_enable_cb = 'Nvim_TB_enable'
        let g:dark_transparent_disable_cb = 'Nvim_TB_disable'
    endif

    if HasPlug('everforest')
        let g:everforest_better_performance = 1
        let g:everforest_background = 'hard'
        " let g:everforest_enable_italic = 1
        function! Everforest_trans_enable()
            let g:everforest_transparent_background = 2
            colorscheme everforest
            call SetStatusLineTheme(&background, 'everforest')
            " hack to fix caret characters appearing in the statusline when StatusLine
            " and StatusLineNC has same highlight(https://vi.stackexchange.com/questions/15873/carets-in-status-line)
            hi StatusLine guifg=#d3c6aa ctermfg=223
        endfunction
        function! Everforest_trans_disable()
            let g:everforest_transparent_background = 0
            colorscheme everforest
            call SetStatusLineTheme(&background, 'everforest')
        endfunction
        function! CB_dark_tb_enable_everforest()
            call Everforest_trans_enable()
        endfunction
        function! CB_light_tb_enable_everforest()
            call Everforest_trans_enable()
        endfunction
        function! CB_dark_tb_disable_everforest()
            call Everforest_trans_disable()
        endfunction
        function! CB_light_tb_disable_everforest()
            call Everforest_trans_disable()
        endfunction

    endif
    if HasPlug('papercolor-theme')
        function! CB_dark_tb_enable_PaperColor()
            let g:PaperColor_Theme_Options = {
            \   'theme': {'default.dark': { 'transparent_background': 1 }}}
            colorscheme PaperColor
        endfunction
        function! CB_light_tb_enable_PaperColor()
            let g:PaperColor_Theme_Options = {
            \   'theme': {'default.light': { 'transparent_background': 1 }}}
            colorscheme PaperColor
        endfunction
        function! CB_dark_tb_disable_PaperColor()
            let g:PaperColor_Theme_Options = {
            \   'theme': {'default.dark': { 'transparent_background': 0 }}}
            colorscheme PaperColor
        endfunction
        function! CB_light_tb_disable_PaperColor()
            let g:PaperColor_Theme_Options = {
            \   'theme': {'default.light': { 'transparent_background': 0 }}}
            colorscheme PaperColor
        endfunction
    endif

    """ THEME_ULTILITIES """
    nmap <Leader>db :call ShowHighLightGroup()<CR>

    function! SetTheme(bg, ...)
        let colors_name = a:0 > 0 ? a:1 : g:my_config[a:bg].theme
        if HasColorscheme(colors_name)
            let g:my_config.background = a:bg
            let g:my_config[a:bg].theme = colors_name
            call SetStatusLineTheme(a:bg)
            execute("colorscheme " . colors_name)
            if &background != a:bg
                execute('set background='.a:bg)
            endif
        endif
    endfunction

    " Change bottom airline/lualine theme
    function! SetStatusLineTheme(bg, ...)
        if has('nvim-0.5')
            " lualine will change theme automatically
        else
            if HasPlug('vim-airline') && exists(':AirlineTheme')
                let theme = a:0 > 0 ? a:1 : g:my_config[a:bg].airline_theme
                try
                    execute('AirlineTheme ' . theme)
                catch
                    let theme = g:default_config[a:bg].airline_theme
                    execute('AirlineTheme ' . theme)
                endtry
                let g:my_config[a:bg].airline_theme = theme
            endif
        endif
    endfunction

    function! EnableTransparent()
        let colorscheme_name = ColourSchemeName()
        let bg = &background
        let cb_name = 'CB_' .bg. '_tb_enable_'.colorscheme_name
        if exists('*' . cb_name)
            execute('call ' . cb_name . '()')
        elseif exists('g:'.bg.'_transparent_enable_cb') && g:dark_transparent_enable_cb != ''
            let cb_name = get(g:, bg.'_transparent_enable_cb', '')
            if cb_name != ''
                execute('call '.cb_name.'()')
            endif
        else
            return
        endif
        let g:my_config[&background].transparent = v:true
    endfunction

    function! DisableTransparent()
        let colorscheme_name = ColourSchemeName()
        let bg = &background
        let cb_name = 'CB_' . bg . '_tb_disable_'.colorscheme_name
        if exists('*' . cb_name)
            execute('call ' . cb_name . '()')
        elseif exists('g:'.bg.'_transparent_disable_cb')
            let cb_name = get(g:, bg.'_transparent_disable_cb', '')
            if cb_name != ''
                execute('call '.cb_name.'()')
            endif
        else
            return
        endif
        let g:my_config[&background].transparent = v:false
    endfunction

    " ToggleTransparent background
    function! ToggleTransparent()
        if g:my_config[&background].transparent
            call DisableTransparent()
        else
            call EnableTransparent()
        endif
    endfunction

    " Allow to trigger background
    function! ToggleBG()
        " Inversion
        let newbg = &background == "dark" ? 'light' : 'dark'
        call SetTheme(newbg)
        if g:my_config[&background].transparent
            call EnableTransparent()
        else
            call DisableTransparent()
        endif
    endfunction

    """ THEME_INIT """
    function! s:theme_initilize()
        let bg = g:my_config.background
        call SetStatusLineTheme(bg)
        if HasColorscheme(g:my_config[bg].theme)
            call SetTheme(bg)
        else
            call SetTheme(bg, g:my_config[bg].default)
        endif

        if g:my_config[bg].transparent
            call EnableTransparent()
        else
            call DisableTransparent()
        endif
    endfunction

    if g:vim_type == 'vim'
        " workaround that statusline theme doesn't work right
        call s:registerLateInit('s:theme_initilize')
    endif
    autocmd VimEnter * call s:theme_initilize()


    """ THEME_OPTIONS """

    if has('termguicolors')
        set termguicolors
    endif

    let g:default_config = {
        \ 'background': 'dark',
        \ 'dark': {
        \   'theme': 'default',
        \   'default': 'default',
        \   'transparent': v:false,
        \   'airline_theme': 'angr',
        \ },
        \ 'light': {
        \   'theme': 'default',
        \   'default': 'default',
        \   'transparent': v:false,
        \   'airline_theme': 'silver',
        \ },
    \ }

    let g:my_config = {}

    let g:colo2airline = {
    \ }

    " permenent default
    if HasPlug("everforest")
        let g:default_config = Merge(g:default_config, {
            \ 'dark': {
            \   'airline_theme': 'everforest',
            \   'default': 'everforest',
            \   },
            \ 'light': {
            \   'airline_theme': 'everforest',
            \   'default': 'everforest',
            \   },
        \ })
    endif

    let g:my_config = Merge(g:default_config, LoadConfig())
" }

"""""" KEY_MAPS """"""
" (This doesn't include plugin specific mapping.
" For them  check plugin Preferences)

    nnoremap <leader>ws :call TrimWhitespace()<CR>

    " Toggle dark/light theme
    noremap <silent> <leader>bg :call ToggleBG()<CR>

    " Toggle transparent background
    noremap <silent> <leader>tb :call ToggleTransparent()<CR>

    " Buffer navigation
    nnoremap <silent> <space>q :bprevious<CR>
    nnoremap <silent> <space>e :bnext<CR>

    " leader s change all occurence
    nnoremap <Leader>s :%s/\<<C-r><C-w>\>/<C-r><C-w>

    " disable two easily mispressed yet useless key
    nnoremap q: <nop>
    nnoremap Q <nop>

    " leader num change tab
    " only for vim or nvim without lualine

    if (g:vim_type == 'vim' || !has('nvim-0.5')) && HasPlug('vim-bufferline')
        for i in range(1, 9)
            execute "nnoremap <silent> <nowait> <leader>" . i .
                \ " :call bufferline#jump(" . i . ")<CR>"
        endfor
        for i in range(10, 20)
            execute "nnoremap <silent> <nowait> <space>" . i .
                \ " :call bufferline#jump(" . i . ")<CR>"
        endfor
    end

    " split window comform with other window management shortcuts
    nnoremap <silent> <C-w>% :vsplit<CR>
    nnoremap <silent> <C-w>" :split<CR>

"""""" OTHERS """"""

" Lua configuration
if has('nvim') && filereadable(g:dotfiledir . '.vimrc.lua')
    execute('source ' . g:dotfiledir . '/.vimrc.lua')
endif

call s:executeLateInit()
